package ch01.sample.chapter_03;

public class ex03_test3_2 {
    public static void main(String[] args) {
        int x = 2;
        int y = 5;
        char c = 'A'; //'A'의 문자코드는 65

        System.out.println(1 + x << 33);
        //'1+x<<33' 는 x의 값이 2이므로 '1+2<<33'가 된다. 덧셈연산자(+)보다 쉬프트 연산자(<<)가 우선순위가 낮으므로 '3<<33'이 된다.
        //int 는  32bit 이므로 33번 쉬프트 하지 않고 1번만 쉬프트 한다. '3<<1'은 3에 '2의 1제곱'인 2르,ㄹ 곱하는 것과 같은 결과를
        //얻으므로 '3*2'가 되어 결국 6을 얻는다.

        System.out.println(y >= 5 || x < 0 && x > 2);
        //x의 값이 2이고, y의 값이 5이므로 위의 식은 'true || false && false'가 된다. 논리연산자 'and(&&)' 는 'or(||)'보다
        // 우선순위가 높기 때문에 'false && false' 가 먼저 연산되어 'true || false'가 되고 최종결과는 true가 된다.

        System.out.println(y += 10 - x++);
        //'y +=10 - x++'를 풀어쓰면, 'y = y +(10-x++)'이 된다. x++은 후위형이기 때문에 x의 값이 증가되지 않은 상태에서 (10-x)는 계산되고
        //x의 값은 1 증가된다.
        // 그래서 (10-2)로 계산이 되고 x의 값은 1 증가하여 3이 된다. y의 값은 4이므로 식은 'y = 5+(10-2)가 되어 y에 13이 저장된다.

        System.out.println(x += 2);
        //'x+=2'는 'x= x+2'와 같다. 이전의 식에서 x의 값이 1증가하였으므로 이제 x의 값은 3이다. 3에서 2를 더했으므로 결과는 5다.

        System.out.println(!('A' <= c && c <= 'z'));
        //!('A' <= c && c <= 'z')는 문자 c가 대문자가 아닌지를 확인하는 조건식이다. 먼저 괄호안의 'A'<=c && c<='Z'기 먼저 계산되고
        //마지막에 이 계산결과가 논리부정연산자(!)에 의해 반대로(true->false)로 바뀐다. c가 'A'이므로 'A'<='A'&& 'A'<='Z'가 되고 양쪽의
        // 조건식이 true이므로 'true&&true'의 결과인 true가 된다. 결과에 논리부정연산(!)을 수행해 true-> false로 변하여 최종결과는 false이다.

        System.out.println('C' - c);
        //이항연산자는 피연산자 int보다 작은 타입(byte, short, char)인 경우 int로 변환한 다음에 연산을 수행한다.
        // c의 값이 'A'이므로 'C'=c는 'C'-'A'가 되고 'C'와 'A'는 int 로 변환되어 '67-65'가 되고 최종결과는 2가 된다.

        System.out.println('5' - '0');
        //'5'-'0'도 위와 같은 이유로 '53-48'이 되어 5다.

        System.out.println(c + 1);
        //c+1은 c의 값이 'A'이므로 'A'+1이 되고, 이항연산자의 성질(int보다 작은 타입은 int로 변환 후 연산)때문에 'A'는 문자코드 값인 65로 변환되어
        // '65+1'을 수행하여 66을 결과로 얻는다. 단지 변수 c에 저장된 값을 읽어서 수식을 계산한 것이므로 변수 c의 저장된 값에는 아무런 변화가 없다.

        System.out.println(++c);
        //단항연산자인'++'은 이항연산자와 달리 int보다 작은 타입도 형변환을 하지 않는다.
        // (이항 연산자는 연산을 위해 ‘피연산자 스택(operand stack)’을 사용하는데 이 과정에서 형변 환이 발생하는 것이다.
        // 반면에 단항연산자인 증가연산자'++'은 ‘피연산자 스택’을 사용 하지 않으므로 형변환도 발생하지 않는다.)
        // 그래서 println은 변수 c를 숫자(int)로 출력 하는 것이 아니라 문자로 출력한다.
        // 변수 c에 저장된 문자가 'A'(실제로 저장된 것은 'A' 의 문자코드인 65)이므로 문자코드의 값이 1증가되어 66('B'의 문자코드)이 변수 c에 저 장된다.
        //변수 c에 저장된 것은 문자코드, 즉 정수값이다. println은 이 값을 타입에 따라 어떻게 출력할지를 결정한다.
        // 만일 문자타입이면 저장된 값(문자코드)에 해당하는 문자를 출력하 고 숫자라면 숫자로 출력한다.

        System.out.println(c++);
        //단항연산자'++'이 후위형인 경우에는 println()에 의해서 변수 c가 출력된 후에 c에 저장 된 값이 증가하므로
        // 문자 'B'가 출력된 후에 변수 c의 값이 1증가해서 문자 'C'가 저장된 다.
        System.out.println(c);

    }
}
